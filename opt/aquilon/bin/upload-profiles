#!/usr/bin/python

import sys
import os
import urllib
import re
import time
import StringIO
import gzip
from optparse import OptionParser

try:
    import ms.version
    ms.version.addpkg("couchdb", "0.8")
    ms.version.addpkg("urllib2_kerberos", "0.1.6-ms1")
    ms.version.addpkg("kerberos", "1.1")
except:
    pass

from xml.etree import cElementTree as ETree

BINDIR = os.path.dirname(os.path.realpath(sys.argv[0]))
sys.path.append(os.path.join(BINDIR, "..", "lib", "python2.6"))
import warehouse
from warehouse import debug

profile_url_re = re.compile('(.*).xml')

def main(argv):
    parser = OptionParser(usage="%prog [options]")
    parser.add_option("-n", "--nochange", dest="nochange", 
                      action="store_true",
                      help="report, but change nothing")
    (options, args) = parser.parse_args()

    debug("startup")
    base = warehouse.get("profiles")
    compress = warehouse.getboolean("compress")
    db = warehouse.get_or_create_db()

    update = dict()
    if 'update' in db:
        update = db['update']

    start = time.time()

    debug("initialising mtimes...")
    mtime = dict()
    for row in db.view("views/profile_mtimes", None):
        mtime[row.key] = row.value

    debug("processing...")
    current_ids = process_info(db, mtime, base, compress, options.nochange)

    debug("cleaning old profiles...")
    for name in mtime:
        if name not in current_ids:
            if options.nochange:
                print "would delete %s" % name
            else:
                debug("deleting %s" % name)
                del db[name]
    end = time.time()

    update['elapsed'] = end - start
    update['last_start'] = start
    if options.nochange:
        print "would modify update: elapsed=%d, start=%d" % (update['elapsed'], update['last_start'])
    else:
        db['update'] = update
    debug("finish")

def process_info(db, mtime, base, compress, nochange):
    etree = ETree.parse(urllib.urlopen(base + '/profiles-info.xml'))
    profiles = etree.getroot()
    ids = set()
    for p in profiles:
        changed = False
        m = profile_url_re.match(p.text)
        if m:
            name = m.group(1)
            ids.add(name)
            if name in mtime:
                if int(p.attrib['mtime']) != mtime[name]:
                    debug("downloading %s" % name)
                    doc = get_profile(base, name, int(p.attrib['mtime']), compress)
                    doc['_rev'] = db[name]['_rev']
                    if nochange:
                        debug("would update %s" % name)
                    else:
                        changed = True
                        debug("updating %s" % name)
                        db[name] = doc
            else:
                debug("downloading %s" % name)
                doc = get_profile(base, name, int(p.attrib['mtime']), compress)
                if nochange:
                    debug("would insert document %s" % name)
                else:
                    changed = True
                    debug("inserting %s" % name)
                    db[name] = doc
            if changed:
                debug("finished with %s" % name)

    return ids

def get_profile(base, name, mtime, compress):
    url = base + '/' + name + '.xml'
    if compress:
        url = url + '.gz'

    doc = urllib.urlopen(url)
    data = doc.read()
    if doc.getcode() != 200:
        return dict() # Raise 404NotFound
    if compress:
        stream = StringIO.StringIO(data)
        content = gzip.GzipFile(fileobj=stream).read()
    else:
        content = data
   
    etree = ETree.fromstring(content)
    fmt = etree.attrib["format"]

    x = dict()
    x['config'] = parse_node(etree, fmt)
    x['mtime'] = mtime
    return x

def parse_node(node, fmt):
    if fmt == "pan":
        type = node.tag
    else:
        type = node.attrib["type"]

    if type == "nlist":
        ret = dict()
        for child in node:
            if fmt == "pan":
                cname = child.attrib["name"]
            else:
                cname = child.tag
            ret[cname] = parse_node(child, fmt)
        return ret
    elif type == "list":
        ret = list()
        for child in node:
            ret.append(parse_node(child, fmt))
        return ret
    elif type == "string":
        return node.text
    elif type == "long":
        return int(node.text)
    elif type == "boolean":
        if node.text == "true":
            return True
        else:
            return False

main(sys.argv)
